This is a Zig project to work with hex timestamps.
I'm doing it mostly to learn Zig, which suits it fairly well.

Here's the site for Zig: https://ziglang.org/

Here's my old repository for shell scripts that work
with the same timestamps:

https://bitbucket.org/x31eq/binaryclock

You might also find a Rust repository that I've been
working on in parallel.

The conclusion of the Zig tryout is that it works quite
well as a replacement for C.  This is interesting because
C has been around for a long time and it holds
the niche of low-level-but-not-assembler very well.
So the question is: is C the best language for this niche
or is it something that gets used because it's ubiquitous
and has tools and operating systems written around it?
I don't know that there were any languages before Zig
that were better than C at being C.  It think Zig is better,
although it isn't a functional superset because it
doesn't have the pre-processor, and hopefully never will.
There are still good reasons to keep using C though:
everybody uses it, the tools are better, and lots of things
are written around it.

The standard library for Zig is sparse and badly documented.
Maybe you found this after searching for help on formatting
with the standard library, in which case, yes, you'll learn
something about hex formatting here.
I worked it out mostly from the source code.
I also replaced the C functions I'd included from "string.h".
But I didn't have to: if the Zig standard library fails you,
you can always fall back on C.  You have to deal with the
strange way C handles strings but otherwise it's simple.

I call out to a standard C library to get the local time.
(I don't know how standard it is -- at least it works in Linux.)
I tried to use "strptime" but it didn't work.
I didn't work out why.  As I didn't try this in C,
I can't be sure that Zig is inferior to C at working with C,
but it does look less than perfect.
The code I wrote for parsing the date and time could
use some improvement, which I can blame on Zig
not being very good at string handling even when
you find things in the standard library.

This project does most of what I wanted it to do now.
The testing could also be improved.  I've got tests that
I copied over from the original shell code, and so they
still run as shell scripts.  They also happen to be
essentially the same as I use for the Rust equivalent.
They'd be faster if they ran in Zig (they take a few minutes)
and there are also features I added that aren't tested.

I used a makefile because although Zig has its own system
that apparently makes them redundant, I don't know how to use it.
I also hard-coded the path I happened to extract the binary to.
You'll probably want to change this.

Compared to Rust, the the Zig code is a bit longer
mostly because I didn't sort out the error handling in Rust.
The two languages are quite similar for a simple task like this.
There are a lot of syntactic similarities, and they both use
union types for error handling (when you don't ignore the errors).

There is, though, a huge difference in the executable size.
The Rust binaries are nearly 8 times the size of the Zig binaries.
Sometimes I even get backtraces out of Zig, so I don't know
where all the bloat goes.  I think a lot of it's the
string formatting, that I do use and that Rust does better,
but there's probably also a lot of code that I don't use
but doesn't get shaken out.  At least, Zig is doing a much
better job of being C-like and producing small binaries
with a minimal runtime.

Another interesting comparison is that the source code of
both Zig and Rust is much longer than the original shell code.
Nearly an order of magnitude, in fact.
To understand this, let's consider what the programs actually do:

1. Read command line arguments

1b. Get the current date and time (not always)

2. Parse an incoming timestamp

3. Do some arithmetic to get the date and time in a different form

4. Format the new datetime and write it to stdout

So, let's see how these things compare.

Step 1a, shells have special syntax for not only reading
command line arguments but substituting in special values.
Rust and Zig both need libraries, which adds a few lines of code.
So one conclusion is that you can work with command line arguments
very efficiently with the shell.

Step 1b, the shell implementations cheat really and use
GNU date to get the current time whereas Rust and Zig use
two-step library calls: get the time, then get broken-down local time.
Also, the GNU date call can easily default to the current time
when it isn't supplied.  In addition, GNU date allows very flexible
input, so the shell implementations get an extra feature from this.
Other languages could have used GNU date as an external process,
but I decided not to do that.

Step 2 also gets handled by GNU date when converting to hex.
When the input is hex, shell makes it easy to split up tokens
from the supplied string and convert it to hex.
So another lesson is that shell support for text handling
works well for the simple things you need for parsing fixed hex strings.
Part of the overhead in Rust and Zig is around static typing.
They also get a few extra features because I decided to add in
a bit more logic, and that could have been done in the shell,
but the shell scripts were so short to start with I didn't want
to complicate them.

Step 3, well, the arithmetic looks much the same in both cases.
There is an extra overhead, particularly in Zig,
from strong typing: shells don't distinguish signed from unsigned
integers, and don't worry about overflow and the like.
I made this a bit hard for myself by using fairly specific
sizes for members of the Time struct, and also because the
system library uses signed integers for things that can
never be negative and so I took on an overhead converting
between signed and unsigned.

Another consideration on the arithmetic is that, because
the code was already getting longer, I used
more descriptive variable names in Rust and Zig and
added some comments to explain what was going on.
So this should mean the code is more readable
to make up for being much longer.

Step 4 is pretty similar in all cases.
The shells use a printf call that's copied from C.
I did originally use printf in Zig as a C import,
but once I worked it out the native library works almost as well
with a couple of extra lines of overhead to get at stdout.
One issue is that Zig formats signed integers with a + sign
when you specify the field width, so I had to ensure
casting to unsigned to get around this, which I mentioned above.
Rust has a println macro that has all the features I need.

The safety of Rust and Zig also gives you the opportunity
to add more informative error messages for bad input.
This isn't something I care about much, but for proper
applications that other people use it would be important.

Now this README is getting to be as big as the code,
at least measured in bytes, and therefore is
much longer than the original shell code.
I think I'll end it here.
